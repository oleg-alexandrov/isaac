<!-- HTML header for doxygen 1.9.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ISAAC: happly::Element Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="favicon.png" type="image/png" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="freeflyer.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 70px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ISAAC
   &#160;<span id="projectnumber">0.2.5</span>
   </div>
   <div id="projectbrief">Flight software for the ISAAC project, adding functionality to the Astrobee robot, operating inside the International Space Station.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classhapply_1_1Element.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classhapply_1_1Element-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">happly::Element Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An element (more properly an element type) in the .ply object. Tracks the name of the elemnt type (eg, "vertices"), the number of elements of that type (eg, 1244), and any properties associated with that element (eg, "position", "color").  
 <a href="classhapply_1_1Element.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="happly_8h_source.html">happly.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af08fe995c4124e50f107556a7a654ded"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#af08fe995c4124e50f107556a7a654ded">Element</a> (const std::string &amp;name_, size_t count_)</td></tr>
<tr class="memdesc:af08fe995c4124e50f107556a7a654ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new element type.  <a href="classhapply_1_1Element.html#af08fe995c4124e50f107556a7a654ded">More...</a><br /></td></tr>
<tr class="separator:af08fe995c4124e50f107556a7a654ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802a3c6fcff5ec462d92d545c6fa7048"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a802a3c6fcff5ec462d92d545c6fa7048">hasProperty</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a802a3c6fcff5ec462d92d545c6fa7048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property exists.  <a href="classhapply_1_1Element.html#a802a3c6fcff5ec462d92d545c6fa7048">More...</a><br /></td></tr>
<tr class="separator:a802a3c6fcff5ec462d92d545c6fa7048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947611fd0338f3646f5f6768bffcd3ff"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a947611fd0338f3646f5f6768bffcd3ff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a947611fd0338f3646f5f6768bffcd3ff">hasPropertyType</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a947611fd0338f3646f5f6768bffcd3ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a property exists with the requested type.  <a href="classhapply_1_1Element.html#a947611fd0338f3646f5f6768bffcd3ff">More...</a><br /></td></tr>
<tr class="separator:a947611fd0338f3646f5f6768bffcd3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37017b42a9ae5e335557e41d606e8e5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#af37017b42a9ae5e335557e41d606e8e5">getPropertyNames</a> ()</td></tr>
<tr class="memdesc:af37017b42a9ae5e335557e41d606e8e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of the names of all properties.  <a href="classhapply_1_1Element.html#af37017b42a9ae5e335557e41d606e8e5">More...</a><br /></td></tr>
<tr class="separator:af37017b42a9ae5e335557e41d606e8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d5c06999d73667e3323f28913c653e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classhapply_1_1Property.html">Property</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a85d5c06999d73667e3323f28913c653e">getPropertyPtr</a> (const std::string &amp;target)</td></tr>
<tr class="memdesc:a85d5c06999d73667e3323f28913c653e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level method to get a pointer to a property. Users probably don't need to call this.  <a href="classhapply_1_1Element.html#a85d5c06999d73667e3323f28913c653e">More...</a><br /></td></tr>
<tr class="separator:a85d5c06999d73667e3323f28913c653e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbbe9acfd2ca454e723d20b9ed54b9f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a0bbbe9acfd2ca454e723d20b9ed54b9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a0bbbe9acfd2ca454e723d20b9ed54b9f">addProperty</a> (const std::string &amp;propertyName, const std::vector&lt; T &gt; &amp;data)</td></tr>
<tr class="memdesc:a0bbbe9acfd2ca454e723d20b9ed54b9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new (plain, not list) property for this element type.  <a href="classhapply_1_1Element.html#a0bbbe9acfd2ca454e723d20b9ed54b9f">More...</a><br /></td></tr>
<tr class="separator:a0bbbe9acfd2ca454e723d20b9ed54b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac0222244e60b8ab55191c8e9d57d58"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adac0222244e60b8ab55191c8e9d57d58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#adac0222244e60b8ab55191c8e9d57d58">addListProperty</a> (const std::string &amp;propertyName, const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;data)</td></tr>
<tr class="memdesc:adac0222244e60b8ab55191c8e9d57d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new list property for this element type.  <a href="classhapply_1_1Element.html#adac0222244e60b8ab55191c8e9d57d58">More...</a><br /></td></tr>
<tr class="separator:adac0222244e60b8ab55191c8e9d57d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a5a0629b3bed4eec7aa497046944df"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a52a5a0629b3bed4eec7aa497046944df"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df">getProperty</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:a52a5a0629b3bed4eec7aa497046944df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of a data from a property for this element. Automatically promotes to larger types. Throws if requested data is unavailable.  <a href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df">More...</a><br /></td></tr>
<tr class="separator:a52a5a0629b3bed4eec7aa497046944df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977434df80605b76e580bbefc1628743"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a977434df80605b76e580bbefc1628743"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a977434df80605b76e580bbefc1628743">getPropertyType</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:a977434df80605b76e580bbefc1628743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of a data from a property for this element. Unlike <a class="el" href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df" title="Get a vector of a data from a property for this element. Automatically promotes to larger types....">getProperty()</a>, only returns if the ply record contains a type that matches T exactly. Throws if * requested data is unavailable.  <a href="classhapply_1_1Element.html#a977434df80605b76e580bbefc1628743">More...</a><br /></td></tr>
<tr class="separator:a977434df80605b76e580bbefc1628743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f920df4e402ed9f5c84c9755d447de"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a00f920df4e402ed9f5c84c9755d447de"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a00f920df4e402ed9f5c84c9755d447de">getListProperty</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:a00f920df4e402ed9f5c84c9755d447de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of lists of data from a property for this element. Automatically promotes to larger types. Throws if requested data is unavailable.  <a href="classhapply_1_1Element.html#a00f920df4e402ed9f5c84c9755d447de">More...</a><br /></td></tr>
<tr class="separator:a00f920df4e402ed9f5c84c9755d447de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c2d1b3616c57d0822c929874e7c7f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae0c2d1b3616c57d0822c929874e7c7f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#ae0c2d1b3616c57d0822c929874e7c7f8">getListPropertyType</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:ae0c2d1b3616c57d0822c929874e7c7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of a data from a property for this element. Unlike <a class="el" href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df" title="Get a vector of a data from a property for this element. Automatically promotes to larger types....">getProperty()</a>, only returns if the ply record contains a type that matches T exactly. Throws if * requested data is unavailable.  <a href="classhapply_1_1Element.html#ae0c2d1b3616c57d0822c929874e7c7f8">More...</a><br /></td></tr>
<tr class="separator:ae0c2d1b3616c57d0822c929874e7c7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50f5237daec63b3df29963b4702a7cf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae50f5237daec63b3df29963b4702a7cf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#ae50f5237daec63b3df29963b4702a7cf">getListPropertyAnySign</a> (const std::string &amp;propertyName)</td></tr>
<tr class="memdesc:ae50f5237daec63b3df29963b4702a7cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a vector of lists of data from a property for this element. Automatically promotes to larger types. Unlike <a class="el" href="classhapply_1_1Element.html#a00f920df4e402ed9f5c84c9755d447de" title="Get a vector of lists of data from a property for this element. Automatically promotes to larger type...">getListProperty()</a>, this method will additionally convert between types of different sign (eg, requesting and int32 would get data from a uint32); doing so naively converts between signed and unsigned types. This is typically useful for data representing indices, which might be stored as signed or unsigned numbers.  <a href="classhapply_1_1Element.html#ae50f5237daec63b3df29963b4702a7cf">More...</a><br /></td></tr>
<tr class="separator:ae50f5237daec63b3df29963b4702a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925fc71912aca6bca5021df980071826"><td class="memItemLeft" align="right" valign="top"><a id="a925fc71912aca6bca5021df980071826"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a925fc71912aca6bca5021df980071826">validate</a> ()</td></tr>
<tr class="memdesc:a925fc71912aca6bca5021df980071826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sanity checks on the element, throwing if any fail. <br /></td></tr>
<tr class="separator:a925fc71912aca6bca5021df980071826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0d3e0a3fbca24c53b838d8a6d69640"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#acc0d3e0a3fbca24c53b838d8a6d69640">writeHeader</a> (std::ostream &amp;outStream)</td></tr>
<tr class="memdesc:acc0d3e0a3fbca24c53b838d8a6d69640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes out this element's information to the file header.  <a href="classhapply_1_1Element.html#acc0d3e0a3fbca24c53b838d8a6d69640">More...</a><br /></td></tr>
<tr class="separator:acc0d3e0a3fbca24c53b838d8a6d69640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994324a2638d2ee7284a86966324adc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a994324a2638d2ee7284a86966324adc3">writeDataASCII</a> (std::ostream &amp;outStream)</td></tr>
<tr class="memdesc:a994324a2638d2ee7284a86966324adc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(ASCII writing) Writes out all of the data for every element of this element type to the stream, including all contained properties.  <a href="classhapply_1_1Element.html#a994324a2638d2ee7284a86966324adc3">More...</a><br /></td></tr>
<tr class="separator:a994324a2638d2ee7284a86966324adc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8430ca772b86480a728305e0f10b5c01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a8430ca772b86480a728305e0f10b5c01">writeDataBinary</a> (std::ostream &amp;outStream)</td></tr>
<tr class="memdesc:a8430ca772b86480a728305e0f10b5c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">(binary writing) Writes out all of the data for every element of this element type to the stream, including all contained properties.  <a href="classhapply_1_1Element.html#a8430ca772b86480a728305e0f10b5c01">More...</a><br /></td></tr>
<tr class="separator:a8430ca772b86480a728305e0f10b5c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c7a1ac57b53bf834cc9778b6f004342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a4c7a1ac57b53bf834cc9778b6f004342">writeDataBinaryBigEndian</a> (std::ostream &amp;outStream)</td></tr>
<tr class="memdesc:a4c7a1ac57b53bf834cc9778b6f004342"><td class="mdescLeft">&#160;</td><td class="mdescRight">(binary writing) Writes out all of the data for every element of this element type to the stream, including all contained properties.  <a href="classhapply_1_1Element.html#a4c7a1ac57b53bf834cc9778b6f004342">More...</a><br /></td></tr>
<tr class="separator:a4c7a1ac57b53bf834cc9778b6f004342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd7edcb167fea88ade3e8a6a63e2d98"><td class="memTemplParams" colspan="2">template&lt;class D , class T &gt; </td></tr>
<tr class="memitem:a5bd7edcb167fea88ade3e8a6a63e2d98"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#a5bd7edcb167fea88ade3e8a6a63e2d98">getDataFromPropertyRecursive</a> (<a class="el" href="classhapply_1_1Property.html">Property</a> *prop)</td></tr>
<tr class="memdesc:a5bd7edcb167fea88ade3e8a6a63e2d98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which does the hard work to implement type promotion for data getters. Throws if type conversion fails.  <a href="classhapply_1_1Element.html#a5bd7edcb167fea88ade3e8a6a63e2d98">More...</a><br /></td></tr>
<tr class="separator:a5bd7edcb167fea88ade3e8a6a63e2d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa055bfdc237d6ec5d302101fc04456f0"><td class="memTemplParams" colspan="2">template&lt;class D , class T &gt; </td></tr>
<tr class="memitem:aa055bfdc237d6ec5d302101fc04456f0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; D &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhapply_1_1Element.html#aa055bfdc237d6ec5d302101fc04456f0">getDataFromListPropertyRecursive</a> (<a class="el" href="classhapply_1_1Property.html">Property</a> *prop)</td></tr>
<tr class="memdesc:aa055bfdc237d6ec5d302101fc04456f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function which does the hard work to implement type promotion for list data getters. Throws if type conversion fails.  <a href="classhapply_1_1Element.html#aa055bfdc237d6ec5d302101fc04456f0">More...</a><br /></td></tr>
<tr class="separator:aa055bfdc237d6ec5d302101fc04456f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac51592d93a8662086e94ae86754b3caa"><td class="memItemLeft" align="right" valign="top"><a id="ac51592d93a8662086e94ae86754b3caa"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>name</b></td></tr>
<tr class="separator:ac51592d93a8662086e94ae86754b3caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb71bd1d6a126e4834537450f6c1325b"><td class="memItemLeft" align="right" valign="top"><a id="abb71bd1d6a126e4834537450f6c1325b"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>count</b></td></tr>
<tr class="separator:abb71bd1d6a126e4834537450f6c1325b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a1f1f4873df11587d3100f4e3dbab4"><td class="memItemLeft" align="right" valign="top"><a id="a58a1f1f4873df11587d3100f4e3dbab4"></a>
std::vector&lt; std::unique_ptr&lt; <a class="el" href="classhapply_1_1Property.html">Property</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>properties</b></td></tr>
<tr class="separator:a58a1f1f4873df11587d3100f4e3dbab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An element (more properly an element type) in the .ply object. Tracks the name of the elemnt type (eg, "vertices"), the number of elements of that type (eg, 1244), and any properties associated with that element (eg, "position", "color"). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af08fe995c4124e50f107556a7a654ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08fe995c4124e50f107556a7a654ded">&#9670;&nbsp;</a></span>Element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">happly::Element::Element </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new element type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name_</td><td>Name of the element type (eg, "vertices") </td></tr>
    <tr><td class="paramname">count_</td><td>Number of instances of this element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adac0222244e60b8ab55191c8e9d57d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac0222244e60b8ab55191c8e9d57d58">&#9670;&nbsp;</a></span>addListProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::addListProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new list property for this element type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property (eg, "double" for a list of doubles) </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property </td></tr>
    <tr><td class="paramname">data</td><td>The data for the property. Outer vector must have the same length as the number of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0bbbe9acfd2ca454e723d20b9ed54b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbbe9acfd2ca454e723d20b9ed54b9f">&#9670;&nbsp;</a></span>addProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::addProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a new (plain, not list) property for this element type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property </td></tr>
    <tr><td class="paramname">data</td><td>The data for the property. Must have the same length as the number of elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa055bfdc237d6ec5d302101fc04456f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa055bfdc237d6ec5d302101fc04456f0">&#9670;&nbsp;</a></span>getDataFromListPropertyRecursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class D , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;D&gt; &gt; happly::Element::getDataFromListPropertyRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhapply_1_1Property.html">Property</a> *&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function which does the hard work to implement type promotion for list data getters. Throws if type conversion fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>The desired output type </td></tr>
    <tr><td class="paramname">T</td><td>The current attempt for the actual type of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>The property to get (does not delete nor share pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data, with the requested type </dd></dl>

</div>
</div>
<a id="a5bd7edcb167fea88ade3e8a6a63e2d98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd7edcb167fea88ade3e8a6a63e2d98">&#9670;&nbsp;</a></span>getDataFromPropertyRecursive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class D , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;D&gt; happly::Element::getDataFromPropertyRecursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhapply_1_1Property.html">Property</a> *&#160;</td>
          <td class="paramname"><em>prop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function which does the hard work to implement type promotion for data getters. Throws if type conversion fails. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">D</td><td>The desired output type </td></tr>
    <tr><td class="paramname">T</td><td>The current attempt for the actual type of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prop</td><td>The property to get (does not delete nor share pointer)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data, with the requested type </dd></dl>

</div>
</div>
<a id="a00f920df4e402ed9f5c84c9755d447de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f920df4e402ed9f5c84c9755d447de">&#9670;&nbsp;</a></span>getListProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; happly::Element::getListProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of lists of data from a property for this element. Automatically promotes to larger types. Throws if requested data is unavailable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data. </dd></dl>

</div>
</div>
<a id="ae50f5237daec63b3df29963b4702a7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50f5237daec63b3df29963b4702a7cf">&#9670;&nbsp;</a></span>getListPropertyAnySign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; happly::Element::getListPropertyAnySign </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of lists of data from a property for this element. Automatically promotes to larger types. Unlike <a class="el" href="classhapply_1_1Element.html#a00f920df4e402ed9f5c84c9755d447de" title="Get a vector of lists of data from a property for this element. Automatically promotes to larger type...">getListProperty()</a>, this method will additionally convert between types of different sign (eg, requesting and int32 would get data from a uint32); doing so naively converts between signed and unsigned types. This is typically useful for data representing indices, which might be stored as signed or unsigned numbers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data. </dd></dl>

</div>
</div>
<a id="ae0c2d1b3616c57d0822c929874e7c7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c2d1b3616c57d0822c929874e7c7f8">&#9670;&nbsp;</a></span>getListPropertyType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; happly::Element::getListPropertyType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of a data from a property for this element. Unlike <a class="el" href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df" title="Get a vector of a data from a property for this element. Automatically promotes to larger types....">getProperty()</a>, only returns if the ply record contains a type that matches T exactly. Throws if * requested data is unavailable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data. </dd></dl>

</div>
</div>
<a id="a52a5a0629b3bed4eec7aa497046944df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a5a0629b3bed4eec7aa497046944df">&#9670;&nbsp;</a></span>getProperty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; happly::Element::getProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of a data from a property for this element. Automatically promotes to larger types. Throws if requested data is unavailable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data. </dd></dl>

</div>
</div>
<a id="af37017b42a9ae5e335557e41d606e8e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37017b42a9ae5e335557e41d606e8e5">&#9670;&nbsp;</a></span>getPropertyNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; happly::Element::getPropertyNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of the names of all properties. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classhapply_1_1Property.html" title="A generic property, which is associated with some element. Can be plain Property or a ListProperty,...">Property</a> names </dd></dl>

</div>
</div>
<a id="a85d5c06999d73667e3323f28913c653e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d5c06999d73667e3323f28913c653e">&#9670;&nbsp;</a></span>getPropertyPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classhapply_1_1Property.html">Property</a>&gt;&amp; happly::Element::getPropertyPtr </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level method to get a pointer to a property. Users probably don't need to call this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A (unique_ptr) pointer to the property. </dd></dl>

</div>
</div>
<a id="a977434df80605b76e580bbefc1628743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977434df80605b76e580bbefc1628743">&#9670;&nbsp;</a></span>getPropertyType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; happly::Element::getPropertyType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>propertyName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a vector of a data from a property for this element. Unlike <a class="el" href="classhapply_1_1Element.html#a52a5a0629b3bed4eec7aa497046944df" title="Get a vector of a data from a property for this element. Automatically promotes to larger types....">getProperty()</a>, only returns if the ply record contains a type that matches T exactly. Throws if * requested data is unavailable. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of data requested </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">propertyName</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data. </dd></dl>

</div>
</div>
<a id="a802a3c6fcff5ec462d92d545c6fa7048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802a3c6fcff5ec462d92d545c6fa7048">&#9670;&nbsp;</a></span>hasProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool happly::Element::hasProperty </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a property exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the target property exists. </dd></dl>

</div>
</div>
<a id="a947611fd0338f3646f5f6768bffcd3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947611fd0338f3646f5f6768bffcd3ff">&#9670;&nbsp;</a></span>hasPropertyType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool happly::Element::hasPropertyType </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if a property exists with the requested type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>The name of the property to get.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the target property exists. </dd></dl>

</div>
</div>
<a id="a994324a2638d2ee7284a86966324adc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994324a2638d2ee7284a86966324adc3">&#9670;&nbsp;</a></span>writeDataASCII()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::writeDataASCII </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(ASCII writing) Writes out all of the data for every element of this element type to the stream, including all contained properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8430ca772b86480a728305e0f10b5c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8430ca772b86480a728305e0f10b5c01">&#9670;&nbsp;</a></span>writeDataBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::writeDataBinary </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(binary writing) Writes out all of the data for every element of this element type to the stream, including all contained properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c7a1ac57b53bf834cc9778b6f004342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c7a1ac57b53bf834cc9778b6f004342">&#9670;&nbsp;</a></span>writeDataBinaryBigEndian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::writeDataBinaryBigEndian </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(binary writing) Writes out all of the data for every element of this element type to the stream, including all contained properties. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The stream to write to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc0d3e0a3fbca24c53b838d8a6d69640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc0d3e0a3fbca24c53b838d8a6d69640">&#9670;&nbsp;</a></span>writeHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void happly::Element::writeHeader </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>outStream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes out this element's information to the file header. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outStream</td><td>The stream to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>dense_map/geometry_mapper/include/<a class="el" href="happly_8h_source.html">happly.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.0-->
<!-- start footer part -->
</body>
</html>
